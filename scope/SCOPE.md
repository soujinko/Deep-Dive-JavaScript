_모던자바스크립트 딥다이브 13 - 15강_
# SCOPE?
스코프 = 네임 스페이스
스코프를 통해 어떤 변수를 참조해야 하는지 결정, 식별자 검색
다른 스코프에서는 같은 이름의 식별자 사용 가능


### 동적 스코프
함수가 호출되는 시점에 동적으로 상위 스코프를 결정
정적 스코프/ 렉시컬 스코프
함수의 정의가 평가되는 시점에서 상위 스코프가 정적으로 결정
자바스크립트를 비롯한 대부분 프로그래밍 언어는 정적 스코프를 따름
호출된 함수의 위치는 상위 스코프 결정에 영향을 미치지 않음


### 스코프 체인
모든 스코프가 계층적으로 연결된 것
변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수 참조 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수 검색


### 렉시컬 환경이란?
코드가 어디서 실행되며 주변에 어떤 코드가 있는지, 즉 코드의 문맥을 이루는 것
전역 렉시컬 환경은 코드가 로드되면 곧바로 생성, 함수의 렉시컬 환경은 함수가 호출되면 생성


### 실행 컨텍스트란?
렉시컬 환경을 구현한 것
모든 코드는 실행 컨텍스트에서 평가되고 실행됨

* * *

### var
같은 스코프 내에서 중복 선언을 허용함
오로지 함수의 코드블록만을 지역스코프로 인정(다른 블록에서는 전역변수)
선언과 동시에 초기화


### let
선언 단계와 초기화 단계 분리
런타임 이전에 선언 단계 실행, 초기화 단계는 변수 선언문 도달했을 때 실행
즉 선언 이전에 접근하면 참조 에러발생
일시적 사각지대 = 스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간 


### const
반드시 선언과 동시에 초기화
재할당이 금지되므로 프로그램 전체에서 공통적 사용 - > 유지보수성 향상
대문자 선언, 스네이크 케이스 표현
원시 값을 할당한 경우 값 변경 불가 -> 재할당을 해야 변경됨
const 키워드로 선언된 변수에 객체를 할당한 경우 값 변경 가능 -> 재할당 없이 변경

    const person = {
        name: 'Lee'
    };
    person.name = 'Kim'
    console.log(person) // {name:'Kim'}
새로운 값을 재할당하는 것은 불가능하지만, 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능


### var? let? const?
변수 선언에는 const 사용을 기본으로
let은 재할당 필요 경우에 제한적으로 사용
변수의 스코프는 최대한 좁게 설정
재할당이 필요한지 불분명할 경우에는 우선 const 선언하고 추후에 변경

* * *

### 전역 객체
코드 실행 전 가장 먼저 생성되는 특수 객체
환경에 따라 전역 객체를 가리키는 식별자가 다양함(window, self, this, global...)
ES11에서는 globalThis로 통일
표준 빌트인 객체(Object, String, Number, Function, Array ..) 와 환경에 따른 호스트객체(클라이언트 Web API, Node.js의 호스트 API), var키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
-> 즉 브라우저 환경에서 전역 객체는 window이므로 브라우저 환경에서 var키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다

    var x = 1; // 전역 변수
    y = 2; // 암묵적 전역
    function foo(){} // 전역 함수 -> 모두 적역 객체 window의 프로퍼티
    
    console.log(window.x); // 1
    console.log(window.y); // 2
    console.log(window.foo); // f foo(){}

그러나 let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아님
보이지 않는 개념적 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재

    let x = 1;
    console.log(window.x); // undefined
    console.log(x); // 1


### 전역변수 문제
검색속도 가장 느림
파일이 분리되어 있어도 하나의 전역 스코프 공유(네임스페이스 오염)
ES6에서는 사용 불가


### 전역 변수 사용 억제 방법
1. 즉시 실행 함수

    (function (){
        var foo = 10;
    }());
    console.log(foo); //foo is not defined

2. 네임스페이스 객체
전역에 담당 객체 생성하고 전역변수로 사용할 변수를 프로퍼티로 추가

    var MYAPP = {};
    MYAPP.name = 'Lee'
    console.log(MYAPP.name)

3. 모듈패턴
클로저 기반 동작
전역 변수를 억제, 캡슐화(객체 특정 프로퍼티, 메서르 감출 목적으로 사용) 구현

    var Counter = (function (){
        var num = 0;
        return {
            increase(){
                return ++num;
            },
            decrease(){
                return --num;
            }
        };
    }());

    console.log(Counter.num); // undefined -> private변수 노출 안됨
    console.log(Counter.increase()); //1
    console.log(Counter.increase()); //2
    console.log(Counter.decrease()); //1
    console.log(Counter.decrease()); //0


